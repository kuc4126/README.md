# 202530208 김은채 1113 강의
# 8챕터 
## 08-1 선형 리스트
### 선형 리스트 정의
* **리스트 (list)**
    * 데이터를 순서대로 나열 해놓은 자료구조
    * 가장 단순한 구조를 가진 리스트를 선형 리스트(linear list) 또는 연결 리스트(linked list)라고 함
    * 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유
    * 즉, 한 사람을 건너뛰어 이야기를 전달할 수 X

* **노드**
    * 리스트의 각 요소
    * 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있음
    * 처음과 끝에 있는 노드는 특별히 각각 머리 노드, 꼬리 노드라고 함
    * 하나의 노드에 비해 바로 앞에 있는 노드를 앞쪽 노드, 바로 뒤에 있는 노드를 다음 노드

### 배열로 선형 리스트 만들기
* 다음 노드 꺼내기 
    * 배열의 각 요소에는 연락할 순서대로 데이터가 저장
    * 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

* 노드의 삽입과 삭제
    * 회원 번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12, 33 사이에 삽입하려면 [b] 와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함
    * 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
    * 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아야 함
    * 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음

## 08-2 포인터를 이용한 연결 리스트
### 포인터로 연결 리스트 만들기
* 노드용 구조체
    * 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있음
* 노드용 구조체는 다음의 두 멤버, 데이터와 넥스트로 구성
    * data:데이터(member형)
    * next: 다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형)
* 이와 같이 자기 자신과 같은 자료형의 객체를 가리키는 데이터가 내부에 포함
* 이러한 자료구조를 자기 참조형이라고 함

* **연결 리스트를 관리하는 구조체 리스트**
    * 노드용 구조체를 사용한 연결 리스트를 나타냉 것
    * 리스트는 두 멤버로 구성되어 있고 모두 노드에 대한 포인터 자료형을 가지고 있음
    * head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고,
    cmt는 현재 선택한 노드를 가리키는 선택 포인터(커서)
    * '검색'한 노드를 선택하고'삭제'하는 용도로 사용
    * 연결 리스트를 관리하는 구조체 리스트는 2개의 포인터만 가짐

* 연결 리스트가 비어 있는지 판단하는 방법
    * 빈 연결 리스트는 노드가 하나도 없는 상태이기 때문에 head가 가리키는 노드도 없음
* 노드가 1개인 연결 리스트를 판단하는 방법
    * 머리 포인터 list -> head가 가리키는 노드는 머리 노드
    * 머리 노드는 리스트의 꼬리 노드이기도 하므로 next값은 널

* 검색을 수행하는 search 함수
    * 검색에 사용하는 알고리즘은 선형 검색이거, 검색할 노드를 만날 때까지 머리 노드부터 스캔
* 노드 스캔은 아래의 조건 중 하나만 성립하면 종료
    
* 검색 과정
    * 스캔하고 있는 노드를 가리키는 포인터 ptr을 list->head로 초기화

    * 검색에 실패하면 널 반환

### 꼬리에 노드를 삽입하는 Allocnode함수
* 꼬리 노드를 찾음 -> 삽입할 노드G를 Allocnode함수로 만듦
    
### 머리 노드를 삭제하는 RemoveFront 함수 
    
### 꼬리 노드를 삭제하는 RemoveRear 함수
* 리스트에 노드가 1개뿐인지 아니면 2개 이상인지에 따라 서로 다른 작업을 수행

## 08-3 커서를 이용한 연결 리스트
### 커서를 사용한 연결 리스트
* 프로그램 실행 중에 데이터의 개수가 크게 바뀌지X 데이터의 개수의 최댓값을 미리 알수 있다고 가정하면 배열을 사용해 효율적으로 연결 리스트를 운용할 수 있음

* 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    * 여기서 포인터 역할을 하는 인덱스를 커서라고 함

## 프리 리스트 구현
### 프리 리스트 
* 삭제한 레코드를 관리하기 위해 사용하는 자료구조  
* 삭제한 여러 레코드를 관리하면 앞에서 발생한 ‘사용하지 않는 빈 배열’의 문제를 해결할 수 있음  
  → 프리 리스트는 앞에서 다른 커서를 연결 리스트로 만들기와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현  

* 노드 구조체 Node에 추가한 멤버  
  * Dnext … 프리 리스트의 다음 포인터(프리 리스트의 다음 노드를 가리키는 다음 커서)  

* 연결 리스트를 관리하는 구조체 List에 추가한 멤버  
  * deleted … 프리 리스트의 머리 커서(프리 리스트의 머리 노드를 가리키는 커서)  
  * max … 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호  

## 08-4 원형 이중 연결 리스트
### 원형 리스트 
* 원형 리스트(circular list)  
  * 선형 리스트의 꼬리 노드가 머리 노드를 가리킴  
  * 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조  
  * 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 ‘널(NULL)’이 아니라 머리 노드의 포인터값이라는 점  
  * 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음  

* 빈 원형 리스트를 판단하는 방법  
  * 노드가 없는(비어 있는) 원형 리스트인지를 판단하려면 오른쪽 식을 사용  

* 노드가 1개인 원형 리스트를 판단하는 방법  
  * 노드가 1개라면 머리 노드의 다음 포인터는 자기 자신의 머리 노드를 가리킴  

* 포인터가 머리 노드를 가리키는지 판단하는 방법  
  * Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용  

* 포인터가 꼬리 노드를 가리키는지 판단하는 방법  
  * Node *형 변수 p가 리스트에 있는 어떤 노드를 가리키는 경우 p가 가리키고 있는 노드가 원형 리스트의 꼬리 노드인지 판단하려면 오른쪽 식을 사용  

### 이중 연결 리스트 알아보기
* 이중 연결 리스트*doubly linked list
    * 선형 리스트의 가장 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조 
    * 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐

* 포인터가 머리 노드를 가리키는지 판단하는 방법 
    * 변수 p가 가리키는 노드가 이중 연결 리스트의 머리 노드인지 판단하려면 오른쪽 식을 사용

* 포인터가 꼬리 노드를 가리키는지 판단하는 방법 
    * p가 가리키고 있는 노드가 꼬리 노드인지 판단하려면 오른쪽 식을 사용

### 원형 이중 연결 리스트 만들기

* 원형 이중 연결 리스트 circular doubly linked list 
    * 앞에서 공부한 두 가지의 개념을 합함

* 노드를 나타내는 구조체 Dnode
    * Dnode는 이중 연결 리스트의 노드에서 사용
        * data ... 데이터
        * prev ... 앞쪽 노드에 대한 포인터
        * next ... 다음 노드에 대한 포인터
* 원형 이중 연결 리스트를 관리하는 구조체 Dlist
    * 선형 리스트의 List와 마찬가지로 머리 노드에 대한 포인터와 선택한 노드에 대한 포인터를 가지고 있음

* 노드를 생성하는 AllocDnode 함수
    * Dnode형 객체를 생성하고 해당 객체의 포인터를 반환하는 함수

* 노드의 멤버값을 설정하는 SetDnode 함수
    * Dnode형 객체의 멤버값을 설정
    * 첫 번째 매개변수 n에 전달받은 Dnode형 객체 포인터를 통해 멤버값을 설정

    * 객체 멤버인 data, prev, next에 두 번째 매개변수가 가리키는 객체의 값, 세 번째 매개변수와 네 번째 매개변수의 포인터값을 대입

* 원형 이중 연결 리스트를 초기화하는 Initialize 함수
    * 텅 비어 있는 상태의 원형 이중 연결 리스트를 만드는 함수

    * 리스트의 머리 부분에 더미 노드가 만들어짐(노드의 삽입, 삭제를 원만히 수행하기 위해 필요)
    * 3개 포인터가 가리키는 대상 모두를, 리스트의 앞쪽에 있는 더미라고 함
        * 머리 포인터 list->head가 가리키는 대상

        * 더미 노드의 앞쪽 포인터 list->head->prev가 가리키는 대상
        * 더미 노드의 다음 포인터 list->head->next가 가리키는 대상

* 리스트가 비어 있는지 검사하는 IsEmpty 함수
    * 더미 노드의 뒤쪽 포인터 list->head->next가 자신의 더미 노드인 list->head를 가리키는지를 판단

    * 함수의 반환값은 리스트가 비어 있는 경우에는 1(아닌 경우에는 0)

* 선택한 노드의 데이터를 출력하는 PrintCurrent / PrintLnCurrent 함수
    * PrintCurrent 함수는 list->cmt가 가리키는 노드의 데이터를 PrintMember 함수를 이용해 출력

    * 리스트가 비어 있는 경우에는 ‘선택한 노드가 없습니다’라는 메시지를 출력
    * PrintLnCurrent 함수는 출력한 후의 개행 문자를 출력


* 노드를 검색하는 Search 함수 - (3)
    * 빈 리스트를 검색하는 경우라 가정하고 이 함수가 정말 검색에 실패하는지(널(NULL)을 반환하는지) 그림 8-25를 통해 확인

    * Ptr에 대입하는 list->head->next 값은 더미 노드에 대한 포인터
    * 다시 말해 ptr은 list->head와 같은 값
    * 그러면 while 문의 제어식 ptr != list->head가 성립되지 않기 때문에 while 문은 실행되지 않고 바로 널(NULL)을 반환하며 함수가 종료

* 바로 다음에 노드를 삽입하는 InsertAfter 함수 - (1)
    * 포인터 p가 가리키는 노드의 바로 다음에 노드를 삽입
    * 그림 8-27에서 노드를 삽입한 위치는 p가 가리키는 노드와 p->next가 가리키는 노드의 사이
        * 1. 새로 삽입할 노드 D를 만들고 만든 노드의 앞쪽 포인터가 가리키는 노드는 B, 뒤쪽 포인터가 가리키는 노드는 C로 설정

        * 2. 노드 B의 뒤쪽 포인터 p->next와 노드 C의 앞쪽 포인터 p->next->prev 모두 새로 삽입한 노드를 가리키도록 업데이트

        * 3. 선택한 포인터 list->cmt가 삽입한 노드를 가리키도록 업데이트

* 머리에 노드를 삽입하는 InsertFront 함수
    * 머리 노드의 바로 뒤에 삽입

    * list->head가 가리키는 더미 노드 뒤에 노드를 삽입
* 꼬리에 노드를 삽입하는 InsertRear 함수
    * 꼬리 노드의 바로 뒤 = 더미 노드의 바로 앞에 삽입

    * list->head->prev가 가리키는 꼬리 노드 뒤에 노드를 삽입

* 노드를 삭제하는 Remove 함수
    * 포인터 p가 가리키는 노드를 삭제하는 함수
    * 삭제 과정
        * 1. 노드 A의 뒤쪽 포인터 p->prev->next가 가리키는 노드가 C(p->next)가 되도록 업데이트

        * 2. 노드 C의 앞쪽 포인터 p->next->prev가 가리키는 노드가 A(p->prev)가 되도록 업데이트하고 p가 가리키는 메모리 영역을 해제
        * 3. 선택한 노드가 삭제한 노드의 앞쪽 노드 A를 가리킬 수 있도록 cmt를 업데이트


* 머리 노드를 삭제하는 RemoveFront 함수
    * Remove 함수를 사용해 포인터 
    list->head->next가 가리키는 머리 노드를 삭제
    * 이때 더미 노드는 삭제하면 안 됨

    * 따라서 list->head가 가리키는 더미 노드가 아닌 그 다음의 노드 list->head->next를 삭제
* 꼬리 노드를 삭제하는 RemoveRear 함수
    * Remove 함수를 사용해서 포인터 list->head->prev가 가리키는 꼬리 노드를 삭제


* 선택한 노드를 삭제하는 RemoveCurrent 함수
    * Remove 함수를 사용해서 포인터 list->cmt가 가리키는 노드를 삭제
* 모든 노드를 삭제하는 Clear 함수
    * 더미 노드를 제외하고 모든 노드를 삭제하는 함수
    * 리스트가 텅 빌 때까지 RemoveFront 함수를 사용해 머리 노드의 삭제를 반복
    * 선택한 포인터 list->cmt가 가리키는 노드는 더미 노드 list->head로 업데이트
* 원형 이중 연결 리스트를 종료하는 Terminate 함수
    * 먼저 Clear 함수를 호출해 모든 노드를 삭제하고 더미 노드의 메모리 영역도 해제

