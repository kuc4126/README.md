# 202530208 김은채 1120강의
# 9챕터
## 9-1 트리란?
### 트리 정의1
* 트리 관련 용어1
    * 트리를 구성하는 요소는 노드와 가지
    * 각각의 노드는 가지를 통해 다른 노드와 연결되어 있음
* 루트
    * 트리의 가장 윗부분에 위치하는 노드
    * 하나의 트리에는 하나의 루트가 있음
    * 그림을 거꾸로 보면 나무 모양과 비슷
* 리프 
    * 트리의 가장 아랫부분에 위치하는 노드 

### 트리 정의하기 - (2)
* 트리 관련 용어 - (2)
* 자식 child
    * 어떤 노드로부터 가지로 연결된 아래쪽 노드
    * 노드는 자식을 여러 개 가질 수 있음
* 부모 parent
    * 어떤 노드에서 가지로 연결된 위쪽 노드
    * 노드는 1개의 부모를 가짐
* 형제 sibling
    * 같은 부모를 가지는 노드
* 조상 ancestor
    * 어떤 노드에서 가지로 연결된 위쪽 노드 모두
* 자손 descendant
    * 어떤 노드에서 가지로 연결된 아래쪽 노드 모두

### 트리 정의하기 - (3)
* 트리 관련 용어 - (3)
    * 레벨 level
        * 루트로부터 얼마나 떨어져 있는지에 대한 값

        * 루트의 레벨은 0이고 루트로부터 가지가 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 늘어남
    * 차수 degree
        * 노드가 갖는 자식의 수

        * 모든 노드의 차수가 n 이하인 트리를 n진 트리라고 함
    * 높이 height
        * 루트부터 가장 멀리 떨어진 리프까지의 거리 (리프 레벨의 최댓값)


### 트리 정의하기 - (4)
* 트리 관련 용어 - (4)
    * 서브 트리 subtree
        * 트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리
    * 널 트리 null tree
        * 노드, 가지가 없는 트리

### 순서 트리와 무순서 트리 정의하기
* 순서 트리와 무순서 트리
    * 형제 노드의 순서가 있는지 없는지에 따라 트리를 두 종류로 분류

    * 형제 노드의 순서를 따지면 순서 트리(ordered tree), 따지지 않으면 무순서 트리(unordered tree)라고 함

### 순서 트리의 탐색 방법 알아보기 - (1)
* 너비 우선 탐색 breadth-first search

    * 낮은 레벨에서 시작해 왼쪽에서 오른쪽 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려감

    * 검색 순서: A → B → C → D → E → F → G → H → I → J → K → L

### 순서 트리의 탐색 방법 알아보기 - (2)
* 깊이 우선 탐색 depth-first search
    * 리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법

    * 리프에 도달해 더 이상 검색을 진행할 곳이 없는 경우에는 부모에게 돌아감
    * 그런 다음 다시 자식 노드로 내려감
    * 두 자식 가운데 한쪽(또는 양쪽)이 없으면 노드를 지나가는 횟수가 줄어들겠지만 노드를 지나가는 최댓값은 3회

### 순서 트리의 탐색 방법 알아보기 - (3)
* 깊이 우선 탐색에서 가능한 노드 방문 종류
    * 전위 순회 Preorder

        * (부모)노드 방문 → 왼쪽 자식 → 오른쪽 자식
        * A → B → D → H → E → I → J → C → F → K → L → G
    * 중위 순회 Inorder
        * 왼쪽 자식 → (부모) 노드 방문 → 오른쪽 자식
        * H → D → B → I → E → J → A → K → F → L → C → G
    * 후위 순회 Postorder
        * 왼쪽 자식 → 오른쪽 자식 → (부모) 노드 방문
        * H → D → I → J → E → B → K → L → F → G → C → A


## 9-2 이진트리와 이진검색트리
### 이진트리 정의하기
* 이진트리 binary tree
    * 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리

    * 노드의 자식은 2명 이하만 유지해야 함
    * 왼쪽 자식과 오른쪽 자식을 구분함
    * 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리(left subtree), 오른쪽 자식을 다시 루트로 하는 서브 트리를 오른쪽 서브 트리(right subtree)라고 함

### 완전 이진 트리 정의하기
* 완전 이진 트리 complete binary tree
    * 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리
        * 1. 마지막 레벨을 제외한 레벨은 노드를 가득 채움
        * 2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없음
    * 높이가 k인 완전 이진 트리가 가질 수 있는 노드의 최댓값은 $2^{k+1}-1$ 개
    * 따라서 n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 $\log{n}$
    * 완전 이진 트리에서 너비 우선 탐색을 하며 각 노드에 0, 1, 2, ... 값을 주면 배열에 저장하는 인덱스와 일대일로 대응

---
## 보충 설명

### 트리의 레벨(level)은 루트에서부터 노드까지 거친 층의 수를 나타내며, 루트는 보통 0레벨 또는 1레벨로 본다.

### 높이(height)는 트리의 최대 레벨과 같으며, 루트에서 가장 먼 리프 노드까지의 경로에 있는 레벨 수(혹은 간선의 최대 개수)를 의미한다.

### 높이가 h일 때 최대 노드의 수 n은 : $n = 2^h - 1$ (단, 높이를 1에서부터 시작)

### n개의 노드를 가질 때, 완전 이진 트리의 최대 높이 h는 : $h = \log_2{n} + 1$ (단, 높이를 1에서부터 시작)

---
### 이진검색트리 살펴보기
* 이진검색트리 binary search tree
    * 이진트리가 다음의 조건을 만족
        * 1. 어떤 노드 N을 기준으로 왼쪽 서브 트리 노드의 모든 키값은 노드 N의 키값보다 작아야 함
        * 2. 오른쪽 서브 트리 노드의 키값은 노드 N의 키값보다 커야 함
        * 3. 같은 키값을 갖는 노드는 없음
* 이진검색트리의 특징
    * 구조가 단순함
    * 중위 순회를 하면 키값의 오름차순으로 노드를 얻을 수 있음
    * 이진 검색과 비슷한 방식으로 빠르게 검색할 수 있음
    * 노드를 삽입하기 쉬움

### 이진검색트리 만들기
* [A] 7을 삭제하는 경우

    * 검색과 마찬가지로 7을 찾아갑니다. 그런 다음 삭제할 노드 7에서 멈춥니다.


    * 부모 노드인 6의 오른쪽 포인터가 7의 자식 노드인 8을 가리키도록 업데이트합니다.

* [B] 자식 노드가 1개인 노드를 삭제하는 경우
    * 삭제 대상 노드가 부모 노드의 왼쪽 자식인 경우 부모의 왼쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함

    * 삭제 대상 노드가 부모 노드의 오른쪽 자식인 경우 부모의 오른쪽 포인터가 삭제 대상 노드의 자식을 가리키도록 함

* [C] 자식 노드가 2개인 노드를 삭제하는 경우
    * 1. 삭제할 노드의 왼쪽 서브 트리에서 키값이 가장 큰 노드를 검색
    * 2. 검색한 노드를 삭제 위치로 옮김(검색한 노드의 데이터를 삭제 대상 노드 위치로 복사)
    * 3. 옮긴 노드를 삭제
        * 옮긴 노드에 자식이 없으면 '[A] 자식 노드가 없는 노드를 삭제하는 경우'에 따라 노드를 삭제
        * 옮긴 노드에 자식이 1개만 있으면 '[B] 자식 노드가 1개인 노드를 삭제하는 경우'에 따라 노드를 삭제

---
# 10 해시
## 10-1 해시법
### 정렬된 배열에 새로운 값 추가하기
* 정렬된 배열에 데이터를 추가
    * a 배열의 앞쪽 10개의 요소에 데이터가 오름차순으로 정렬된 상태로 저장
* 배열에 35를 추가하려면 아래와 같은 작업이 필요
    * 1. 삽입할 위치가 a[5]와 a[6] 사이임을 이진 검색법으로 조사
    * 2. 그림 b와 같이 a[6] 이후의 모든 요소를 하나씩 뒤로 이동
    * 3. a[6]에 35를 대입
* 요소 이동에 필요한 복잡도(time-complexity)는 O(n)이며 이 비용은 적은 비용이 아님

### 해시법 정의하기 - (1)
* 해시법 hashing - (1)
    * 데이터를 저장할 위치(인덱스)를 간단한 연산으로 구하는 것으로, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행하는 방법
    * 그림 10-2의 a에서 볼 수 있는 배열의 키값(각 요소 값)을 배열의 요소 개수 13으로 나눈 나머지로 다시 정리하면 표 10-1과 같음
    * 표에 정리한 값을 해시값(hash value)이라고 하며, 이 해시값은 데이터에 접근할 때 사용
    * 해시값이 인덱스가 되도록 원래의 키값을 저장한 배열이 해시 테이블(hash table)

### 해시법 정의하기 - (2)
* 해시법 hashing - (2)
    * 배열에 35를 추가하는 경우 35를 13으로 나눈 나머지는 9이므로 b처럼 a[9]에 값(35)을 저장
    * 이전의 '추가한 값 이후의 배열 요소를 모두 옮겼던 경우'와는 다르게 새로운 값을 추가하더라도 다른 배열 요소를 뒤로 옮기지 않아도 됨
    * 이렇게 키값(35)을 가지고 해시값(9)을 만드는 과정을 해시 함수(hash function)라고 함
    * 해시 함수는 여기서 살펴보았듯이 '나머지를 구하는 연산' 또는 이런 나머지 연산을 다시 응용한 연산을 사용
    * 해시 테이블의 각 요소를 버킷(bucket)이라고 함

### 충돌 살펴보기 - (1)
* 충돌 collision
    * 저장할 버킷이 중복되는 현상
    * 배열에 새로운 값 18을 추가하는 경우 18을 13으로 나눈 나머지인 해시값은 5이고 저장할 곳은 버킷 a[5]
    * 그런데 그림 10-3처럼 이 버킷은 이미 채워져 있음
    * 키값과 해시값의 대응 관계가 반드시 1대1이라는 보증은 없음(보통 n대1)
* 충돌에 대한 대처
    * 1. 체인법: 같은 해시값을 갖는 요소를 연결 리스트로 관리
    * 2. 오픈 주소법: 빈 버킷을 찾을 때까지 해시를 반복

### 충돌 살펴보기 - (2)
* 키값과 데이터
    * 해시법을 사용하는 프로그램에서 다루는 데이터는 단순한 정수나 실수가 아니라 여러 데이터가 결합된 '구조체'인 경우가 적지 않음
    * 체인법과 오픈 주소법을 배우기 전에 프로그램에서 사용할 데이터인 구조체를 먼저 정의

### 체인법 살펴보기 - (1)
* 체인법 chaining
    * 해시값을 갖는 데이터를 쇠사슬(chain) 모양으로 연결 리스트에서 연결하는 방법으로, 오픈 해시법(open hashing)이라고도 함
* 같은 해시값을 갖는 데이터 저장하기
    * 배열의 각 버킷(해시 테이블)에 저장하는 값은 그 인덱스를 해시값으로 하는 연결 리스트의 첫 번째 노드(node)에 대한 포인터
        * 그림 10-4에서 69와 17의 해시값은 모두 4이며, 이들을 연결하는 연결 리스트의 첫 번째 노드에 대한 포인터를 table[4]에 저장
        * 또 해시값(인덱스) 0과 2처럼 데이터가 하나도 없는 버킷의 값은 널(NULL) 포인터값을 저장

### 오픈 주소법 이해하기 - (1)
* 오픈 주소법 open addressing
    * 충돌이 발생했을 때 재해시(rehashing)를 수행하여 비어 있는 버킷을 찾아내는 방법으로, 닫힌 해시법(closed hashing)이라고도 함
    * 빈 버킷을 만날 때까지 재해시(rehashing)를 여러 번 반복하므로 연결 탐사법(linear probing)이라고도 함
* 요소 삽입
    * a는 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우
    * 이럴 때 사용하는 방법이 재해시(rehashing)
        * 재해시를 하면 $(18 + 1) \ \% \ 13$의 결과값(6)을 얻을 수 있음
    * b처럼 인덱스가 6인 버킷도 데이터가 채워져 있으므로 재해시 $(19 + 1) \ \% \ 13$의 결과값(7)을 얻을 수 있음
    * c처럼 인덱스가 7인 버킷에 새로운 데이터(18)를 삽입

### 오픈 주소법 이해하기 - (2)
* 요소 삭제
    * 인덱스가 5인 값을 삭제하려면 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇지 않음
    * 왜냐하면 같은 해시값을 갖는 18을 검색할 때 '해시값이 5인 데이터는 존재하지 않는다'라고 생각하여 검색에 실패하기 때문
    * 그래서 각 버킷에 대해 아래의 속성을 부여
        * 1. 데이터 저장 속성값
        * 2. 비어 있음 속성값(-)
        * 3. 삭제 마침 속성값($\star$)
    * 5를 삭제할 때 그림 10-10처럼 그 위치의 버킷에 삭제를 마쳤음을 나타내는 속성값으로 '$\star$'을 저장


### 오픈 주소법 이해하기 - (3)
* 요소 검색
    * 값 17을 검색
        * 해시값이 4인 버킷을 보면 속성값이 '비어 있음(-)'이므로 검색 실패
    * 값 18을 검색
        * 해시값이 5인 버킷을 보면 그 속성은 '삭제 마침($\star$)'
        * 그림 10-11처럼 재해시를 수행하여 6인 버킷을 다시 검색
        * 여기에는 값 6이 저장되어 있으므로 다시 재해시를 수행하여 7인 버킷을 검색
        * 검색하는 값 18이 저장되어 있으므로 검색 성공