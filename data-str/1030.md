# 202530208 김은채 1030강의

# 1. 스택이란

### 스택 stack

* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조
* 데이터의 입력과 출력 순서는 후입선출 LIFO Last In First Out
* 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
* 푸시 push  스택에 데이터를 넣는 작업
* 팝 pop  스택에서 데이터를 꺼내는 작업
* 꼭대기 top  푸시 팝을 하는 위치
*   테이블에 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥 bottom  스택의 가장 밑바닥 부분


### 스택의 구현 예

* 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
* 가장 먼저 main 함수를 실행하며 main 함수는 z 함수를 호출
* 호출된 함수 z는 x 함수와 y 함수를 순서대로 호출
* 함수를 호출할 때는 푸시하고, 함수가 실행을 종료하고 호출한 원래의 함수로 돌아갈 때는 종료된 함수를 팝함

* main -> z -> x -> y 순서대로 함수를 호출
*   이때 스택의 상태는 호출한 함수의 역순으로 겹겹이 쌓여 있어
*   함수 호출이 계층 구조로 이루어져 있음
*   이 상태에서 y 함수의 실행이 종료되면 y 함수만 팝함


# 2. 큐
### 큐 알아보기

* **큐(Queue)**
    * 데이터를 일시적으로 쌓아 두기 위한 자료구조
    * 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 **선입선출(FIFO: First-In, First-Out) 구조**를 이름
    * 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열과 같음
    * **인큐(en-queue)**: 큐에 데이터를 넣는 작업
    * **디큐(de-queue)**: 데이터를 꺼내는 작업
    * **프런트(front)**: 데이터를 꺼내는 쪽
    * **리어(rear)**: 데이터를 넣는 쪽


# 3. 원형 큐
### 링 버퍼로 큐 만들기 – (7)

  * **인큐 함수 Enque**
      * 큐에 데이터를 인큐하는 함수
      * **a** 처음부터 차례대로 데이터 7개 {3, 5, 2, 6, 9, 7, 1}을 넣은 큐에 8을 인큐
          * 1 **que[rear]**(**que[2]**)에 인큐할 데이터를 저장하고, **rear**와 **num** 값을 1만큼 증가
          * 만약 인큐하기 전의 **rear** 값이 배열의 물리적인 끝(11)이라면 **Enque** 함수를 수행한 다음에는 **rear** 값이 12가 되면서 **max**(12)와 같아지는 **인덱스 초과 문제**가 발생
      * **b** **rear** 값이 11인 큐에 9를 인큐
          * 2 **rear** 값을 1만큼 증가했을 때 큐의 최대 용량의 값인 **max**와 같아지면 **rear** 값을 배열의 **첫 인덱스 0으로 변경**해야 함

### 링 버퍼로 큐 만들기 – (12)

  * **모든 데이터를 출력하는 함수 Print**
      * 큐의 모든 데이터를 처음부터 끝까지 순서대로 출력하는 함수
  * **종료 함수 Terminate**
      * 메모리 공간에 할당한 배열(큐)을 해제하는 함수

 # 5. 정렬
### 정렬 정의하기

* **정렬 sorting**
    * 이름, 학번, 키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
    * 키값이 작은 데이터를 앞쪽에 놓으면 오름차순 (ascending order) 정렬, 그 반대로 놓으면 내림차순 (descending order) 정렬이라고 부름

### 정렬 알고리즘의 안정성

* 안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것

### 정렬 알고리즘의 핵심 요소

* 교환, 선택, 삽입
---
### 버블 정렬(1)

* **패스 pass**
    * 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 그림 6-3과 같은 상태가 됨
    * 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
    * 이런 일련의 과정(비교, 교환 작업)을 패스(pass)라고 함

    ![이미지](https://i.ibb.co/QjzCx3n5/2025-10-30-121818.png"이미지")

    ### 버블 정렬(2)

* **패스 수행 횟수**
    * 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회 적은 n-2회
    * 왜냐하면 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문에
    * 패스를 k회 수행하면 앞쪽의 요소 k개가 정렬
    * 모든 정렬이 끝나려면 n-1회의 패스가 수행되어야 함


    ### 버블 정렬 - (3)

* **알고리즘 개선 - (1)**
    * 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않음
    * 즉, 어떤 패스에서 요소의 **교환 횟수가 0**이면 더 이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈추면 됨

  
* **알고리즘 개선 - (2)**
    * 마지막 교환($\star$) 이후에 앞쪽의 세 요소($\{1, 3, 4\}$)는 정렬된 상태
    * 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 좋음